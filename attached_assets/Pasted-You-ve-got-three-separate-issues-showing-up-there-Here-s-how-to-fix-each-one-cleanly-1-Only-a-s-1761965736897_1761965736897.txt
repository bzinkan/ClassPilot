You’ve got three separate issues showing up there. Here’s how to fix each one cleanly.

1) “Only a single offscreen document may be created”

You’re creating the offscreen doc more than once. Gate it and reuse it.

// service-worker.js
let creatingOffscreen;

async function ensureOffscreen() {
  if (await chrome.offscreen.hasDocument()) return;

  if (!creatingOffscreen) {
    creatingOffscreen = chrome.offscreen.createDocument({
      url: 'offscreen.html',
      reasons: ['USER_MEDIA'],
      justification: 'Run WebRTC + screen capture without a visible tab'
    }).catch(e => { creatingOffscreen = null; throw e; });
  }
  await creatingOffscreen;
}

async function closeOffscreen() {
  if (await chrome.offscreen.hasDocument()) {
    await chrome.offscreen.closeDocument();
  }
  creatingOffscreen = null;
}


Call await ensureOffscreen() once before you send any message to the offscreen page. When you stop sharing, call closeOffscreen().

2) “Receiving end does not exist” (when forwarding offer/ICE)

That error means you sent a message to the offscreen page before it existed or before it finished loading/listening.

Add a ready handshake and retry logic:

// service-worker.js
let offscreenReady = false;

// listen for the ready ping from offscreen
chrome.runtime.onMessage.addListener((msg, _sender, sendResponse) => {
  if (msg.type === 'OFFSCREEN_READY') {
    offscreenReady = true;
    sendResponse({ok:true});
  }
});

// before forwarding a signal
async function sendToOffscreen(payload) {
  await ensureOffscreen();
  if (!offscreenReady) {
    await new Promise(r => setTimeout(r, 50)); // tiny wait
  }
  return chrome.runtime.sendMessage({ type: 'SIGNAL', payload });
}


In offscreen.js send the ready ping on load:

// offscreen.js
window.addEventListener('DOMContentLoaded', () => {
  chrome.runtime.sendMessage({ type: 'OFFSCREEN_READY' });
});


Then, in your WS handler inside the service worker, forward the teacher’s offer/ice only via sendToOffscreen(...) (after await ensureOffscreen()).

3) “Screen share request error: Extension has not been invoked for the current page (see activeTab permission). Chrome pages cannot be captured.”

That’s from trying to use chrome.tabCapture on a page that isn’t eligible (e.g., chrome://, Web Store, or not the active tab with a user gesture). On Chromebooks, the most robust path is to avoid tabCapture and use getDisplayMedia() from the offscreen page:

// offscreen.js
async function startCapture() {
  // capture full screen / window / tab via the user picker
  const stream = await navigator.mediaDevices.getDisplayMedia({
    video: { frameRate: 15 },  // tune later
    audio: false
  });
  return stream;
}


If you must support tab-only capture, trigger it from a page context you control (not the service worker) and never against Chrome/extension pages. But for your MVP, getDisplayMedia() is simpler and avoids activeTab pitfalls.

A stable, minimal flow that works

Service worker (student side)

// when teacher clicks “Go Live”, your server sends {type:'request-share'}
async function onRequestShare(meta) {
  await ensureOffscreen();
  await chrome.runtime.sendMessage({ type: 'START_SHARE', meta }); // offscreen prepares PC + stream
  // (optional) send ack to server: student is ready
}

// when a WebSocket 'offer' or 'ice' arrives from teacher:
ws.onmessage = async ({ data }) => {
  const msg = JSON.parse(data);
  if (msg.type === 'offer' || msg.type === 'ice') {
    await sendToOffscreen(msg); // forwards to offscreen.js
  }
};

// when stopping
async function onStopShare() {
  await chrome.runtime.sendMessage({ type: 'STOP_SHARE' });
  await closeOffscreen();
}


Offscreen page

let pc, ws, stream, teacherId;
const ICE = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'turn:turn.yourturn.com:3478', username: 'u', credential: 'p' }
];

chrome.runtime.onMessage.addListener(async (msg, _sender, sendResponse) => {
  try {
    if (msg.type === 'START_SHARE') {
      stream = await navigator.mediaDevices.getDisplayMedia({ video: { frameRate: 15 }, audio: false });
      pc = new RTCPeerConnection({ iceServers: ICE });
      stream.getTracks().forEach(t => pc.addTrack(t, stream));
      pc.onicecandidate = e => e.candidate && ws?.send(JSON.stringify({ type: 'ice', to: teacherId, candidate: e.candidate }));
      sendResponse({ ok: true });
      return true;
    }
    if (msg.type === 'STOP_SHARE') {
      stream?.getTracks().forEach(t => t.stop());
      pc?.close(); pc = null; stream = null;
      sendResponse({ ok: true });
      return true;
    }
    if (msg.type === 'SIGNAL') {
      const sig = msg.payload;
      if (sig.type === 'offer') {
        teacherId = sig.from;
        await pc.setRemoteDescription(sig.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws?.send(JSON.stringify({ type: 'answer', to: teacherId, sdp: pc.localDescription }));
      } else if (sig.type === 'ice') {
        await pc?.addIceCandidate(sig.candidate);
      }
      sendResponse({ ok: true });
      return true;
    }
  } catch (e) {
    console.error('[Offscreen]', e);
    sendResponse({ ok: false, error: String(e) });
  }
});

// set up WS here (or let SW own WS and only pass signals through)


Teacher dashboard

When you click Go Live, first send request-share to the student.

Wait for a simple “ready” ACK (optional), then create the offer and send it.

On answer, attach stream to the tile’s <video>.

Quick checklist that should unblock you

 Call await ensureOffscreen() once; reuse the same offscreen doc.

 Add the OFFSCREEN_READY handshake before you forward signals.

 Use getDisplayMedia() in offscreen.js (drop tabCapture for now).

 Don’t try to capture chrome:// or the Web Store; pick a normal window/tab in the picker.

 Ensure your ICE list includes a TURN server (school networks often need it).